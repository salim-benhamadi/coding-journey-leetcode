# 74. Search a 2D Matrix

## Problem Statement

You are given an `m x n` integer matrix `matrix` with the following two properties:
* Each row is sorted in non-decreasing order.
* The first integer of each row is greater than the last integer of the previous row.

Given an integer `target`, return `true` *if* `target` *is in* `matrix` *or* `false` *otherwise*.

You must write a solution in `O(log(m * n))` time complexity.

## Examples

### Example 1:
```
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
Output: true
```

### Example 2:
```
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
Output: false
```

## Constraints
* `m == matrix.length`
* `n == matrix[i].length`
* `1 <= m, n <= 100`
* `-10^4 <= matrix[i][j], target <= 10^4`

## Solution: Two-Level Binary Search

```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        top, bottom = 0, len(matrix) - 1

        while top <= bottom:
            mid_row = (top + bottom) // 2
            current_row = matrix[mid_row]
            row_start, row_end = current_row[0], current_row[-1]
            
            if target <= row_end and target >= row_start:
                left, right = 0, len(current_row) - 1
                while left <= right:
                    mid_col = (left + right) // 2
                    if target == current_row[mid_col]:
                        return True
                    elif current_row[mid_col] < target:
                        left = mid_col + 1
                    elif current_row[mid_col] > target:
                        right = mid_col - 1
                return False
            elif row_start > target:
                bottom = mid_row - 1
            elif row_end < target:
                top = mid_row + 1
                
        return False
```

### Complexity Analysis

- **Time Complexity**: O(log(m) + log(n)) = O(log(m * n)), where m is the number of rows and n is the number of columns
  - First binary search to find the correct row: O(log(m))
  - Second binary search within the row to find the target: O(log(n))
  - This meets the required O(log(m * n)) time complexity

- **Space Complexity**: O(1)
  - We only use a constant amount of extra space for variables
  - The algorithm operates without using additional data structures