# 334. Increasing Triplet Subsequence

## Problem Statement

Given an integer array `nums`, return `true` if there exists a triple of indices `(i, j, k)` such that `i < j < k` and `nums[i] < nums[j] < nums[k]`. If no such indices exists, return `false`.

## Input
* `nums`: An integer array where `1 <= nums.length <= 5 × 10^5`

## Output
* A boolean: `true` if an increasing triplet exists, `false` otherwise

## Constraints
* `1 <= nums.length <= 5 × 10^5`
* `-2^31 <= nums[i] <= 2^31 - 1`

## Examples

### Example 1:
```
Input: nums = [1,2,3,4,5]
Output: true
Explanation: Any triplet where i < j < k is valid.
For example: indices (0, 1, 2) with values (1, 2, 3).
```

### Example 2:
```
Input: nums = [5,4,3,2,1]
Output: false
Explanation: No triplet exists. The array is strictly decreasing.
```

### Example 3:
```
Input: nums = [2,1,5,0,4,6]
Output: true
Explanation: The triplet at indices (3, 4, 5) has values (0, 4, 6).
0 < 4 < 6, so return true.
```

### Example 4:
```
Input: nums = [20,100,10,12,5,13]
Output: true
Explanation: The triplet at indices (0, 3, 5) has values (20, 12, 13) is invalid.
But the triplet at indices (2, 3, 5) has values (10, 12, 13) is valid.
10 < 12 < 13, so return true.
```

## Solution: Two Variable Tracking Approach

```python
class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
        first_min = second_min = float('inf')
        
        for num in nums:
            if num <= first_min:
                first_min = num
            elif num <= second_min:
                second_min = num
            else:
                return True
        
        return False
```

### Complexity Analysis

- **Time Complexity**: O(n), where n is the length of the array
  - Single pass through the array
  - Each element processed once with constant time operations

- **Space Complexity**: O(1)
  - Only using two variables
  - No additional data structures
