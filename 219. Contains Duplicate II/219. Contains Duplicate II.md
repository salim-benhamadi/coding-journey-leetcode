# 219. Contains Duplicate II

## Problem Statement

Given an integer array `nums` and an integer `k`, return `true` *if there are two ****distinct indices**** *`i`* and *`j`* in the array such that *`nums[i] == nums[j]`* and *`abs(i - j) <= k`.

## Examples

### Example 1:
```
Input: nums = [1,2,3,1], k = 3
Output: true
```

### Example 2:
```
Input: nums = [1,0,1,1], k = 1
Output: true
```

### Example 3:
```
Input: nums = [1,2,3,1,2,3], k = 2
Output: false
```

## Constraints
* `1 <= nums.length <= 10^5`
* `-10^9 <= nums[i] <= 10^9`
* `0 <= k <= 10^5`

## Solution 1: Hash Map Approach

```python
class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        if len(set(nums)) == len(nums):
            return False
            
        index_map = {}

        for current_index, value in enumerate(nums):
            if value in index_map:
                if abs(current_index - index_map[value]) <= k:
                    return True
            index_map[value] = current_index
            
        return False
```

### Complexity Analysis

- **Time Complexity**: O(n), where n is the length of the nums array
  - Creating the set for initial check is O(n)
  - Single pass through the array is O(n)
  - Hash map operations (lookup, insertion) are O(1) on average

- **Space Complexity**: O(min(n, k+1))
  - In the worst case, we might store up to n elements in the hash map
  - The set creation requires O(n) space
  - Overall space is O(n)

## Solution 2: Sliding Window Approach

```python
class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        if len(set(nums)) == len(nums):
            return False
        
        for current_index in range(len(nums)):
            current_value = nums[current_index]
            window_end = min(current_index + 1 + k, len(nums))
            
            if current_value in nums[current_index + 1:window_end]:
                return True
                
        return False
```

### Complexity Analysis

- **Time Complexity**: O(n * k), where n is the length of the nums array
  - Outer loop runs n times
  - For each iteration, we check a slice of size up to k
  - In the worst case, this becomes O(n * k)

- **Space Complexity**: O(n)
  - Creating the set for initial check requires O(n) space
  - The slicing operation creates temporary lists of size up to k
  - Overall space is O(n)
